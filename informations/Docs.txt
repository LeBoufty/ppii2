Fonctions :
 -selection_de_points(List_points :List, Départ : coord*, Arrive : coord*)->List_points_Trie : list_t*, IDepart : Int, IArrivee : Int, taille : Int
   La sélection de points prend en entrée la liste des stations et fait du preprocessing, en gros elle enlève tous les points qui sont trop loin de nos
   points.
   Donc, en entrée, on a la liste des stations, les coordonnées du départ et de l'arrivée. Et en sortie la liste (chaînée possiblement) des points
   qui nous sont utiles. Et l'index du point de départ, d'arrivée et la longueur de la liste.

      Info complémentaire : Il faudra peut-être avoir une fonction qui donne le nom d'une station en fonction de son indice dans liste de sortie.

 -gen_Matrice(List_points_Trie : list_t*, Taille : Int)->Matrice_Adj : float**
   Cette fonction génère la matrice d'adjacence à l'aide de la liste des points de la fonction Selection_de_points. Et elle fait en même temps la réduction
   des arcs inutiles grâce à l'autonomie.
   Donc, en entrée, on a la liste de points, l'autonomie et la taille de liste(C'est pour éviter d'avoir à la recalculer). Et en sortie donne la matrice d'adjacence.

 -plus_courts_chemin(Matrice_Adj : float**, IDepart : Int, IArrive : Int, Autonomie : Int)-> Chemin: List
   Grâce à la matrice d'adjacence (et 2-3 fonctions parallèles) calcul le plus court chemin entre le point de départ et le point d'arrivée.
   En entrée, il nous faut la matrice d'adjacence, l'indice du point de départ et l'indice du point d'arrivée (Il faudra faire une réu de chantier pour
   les indices dans la matrice, ça va être un beau bordels) et en sortie la liste des points de passage (en indice ou autre).

Partie 2 :

Tick par tick
Intervalle de 10min sauf que vitesse constante => distance fixe donc pas besoin de réfléchir en temps


Initialisation n=0
Voitures aléatoires et trajets aléatoires
Determination du trajet/voiture et des distance_de_borne

n->n+1
Cherche les utilisateurs à distance_de_borne=0.
Lance le rechargement, file d'attente ou fin de trajet.
Cherche les voitures chargées pour commencer le nouveau trajet.
Baisse distance_de_borne de 1 et le taux_de_charge (pour distance_de_borne!=0) et augmente le taux_de_charge pour les autres.

fin si nb utilisateurs = 0 


  -utilisateur_rdm(list_v : voiture_tab*, list_s : station_tab*, n : int)-> liste_utilisateurs: utilisateurs*
    Utilité : Prend en paramètre la liste des voitures, des stations ainsi qu'un nombre d'utilisateurs n à générer. Génère de façon aléatoire n trajet associée à n voitures. 
    I/O : Produit une liste chaîné faite avec la struct utilisateurs de n maillons avec un point de départ matérialisé avec les coordonnées x et y, ainsi qu'un modèle de voiture.

  -trajets(list_u: utilisateur*)->info: utilisateurinfo* 
	  Utilité : Pour chaque utilisateur calcule le chemin entre le point de départ et d'arriver (partie 1). /!\ Penser aux id_stations relatives.
	  I/O Entrée : list_u liste d'utilisateur à qui il faut calculer la trajet
		    Sortie : Liste chainée de trajets/distance_de_borne/taux_de_charge 
	  Info supp : on peut juste faire une liste chainée et suppr le chainon(list_u et la sortie) quand c'est fini   

i -traitement(info: utilisateurinfo*)->Etat_reseau int* (Grosse fonction)
	  Utilité : Parcours la liste chainée pour trouver les utilisateur à une distance_de_borne=0, gère les différents cas (Lance le rechargement, file d'attente ou fin de trajet.), gère le rechargement et gère le prochain tick. En gros, elle gère tout le tick de 10min en faisant 1 seul parcours de la liste.
	  I/O 	Entrée : list_truc la liste des trajets avec leur distance_de_borne
		      Sortie : retourne l'état du réseau à l'instant n 
